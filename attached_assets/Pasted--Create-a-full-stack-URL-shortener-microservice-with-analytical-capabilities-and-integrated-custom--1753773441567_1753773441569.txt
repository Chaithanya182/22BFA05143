
Create a full-stack URL shortener microservice with analytical capabilities and integrated custom logging middleware. Your project should be structured into three main folders:



logging-middleware/ — reusable logging function calling the official test server.



backend-test-submission/ — Express + SQLite backend implementing URL shortening APIs.



frontend-test-submission/ — React (with Material UI) frontend consuming backend APIs.



Requirements

1. Logging Middleware:



Must be a standalone reusable module/function that authenticates with the test server and sends structured logs (stack, level, package, message).



Used extensively by both backend routes and frontend components for all significant events and errors.



No console logs or built-in logger usage allowed.



2. Backend Microservice:



Use Node.js, Express, and SQLite database (with sqlite and sqlite3 packages).



No user authentication needed; APIs are open access.



Provide these endpoints:



POST /shorturls — Create a shortened URL. Request body includes:



url (string, required): Valid full URL.



validity (integer, optional): Expiry period in minutes (default 30).



shortcode (string, optional): Custom shortcode; must be unique and valid (alphanumeric, reasonable length).



Response: JSON with generated short link and ISO expiry timestamp.



GET /shorturls/:shortcode — Retrieve statistics of a short URL, including:



Original URL, creation and expiry dates, total clicks, and detailed click records (timestamp, referrer, coarse location).



GET /:shortcode — Redirect to original URL if not expired, increment click count, store click metadata.



Enforce shortcode uniqueness and validity.



Track clicks with timestamp, referrer header, and IP/location info.



Use parameterized SQL queries for safety.



Use logging middleware to log success/info/error events in backend workflows.



Use clear, beginner-style code: require(), async/await, simple modules, commenting, error handling with try/catch.



3. Frontend Application:



React app running on http://localhost:3000 only.



Use Material UI for all styling. No other CSS frameworks allowed (vanilla CSS permitted only if needed).



Users can input up to 5 URLs at once, each with optional validity and shortcode fields.



Client-side validate inputs (valid URL format, optional fields as integer/alphanumeric).



Display shortened URLs with expiry times clearly.



Provide a statistics page listing all created short URLs with click stats and details.



Use the logging middleware to log user actions and errors (frontend version of logger).



Communicate only with your backend APIs; no logic duplication in frontend.



Your Style Requirements for Code

Simple, clean, human-friendly code like your previous examples:



Use CommonJS require() style imports.



Use async/await syntax clearly.



Split code into meaningful modules but keep file size manageable (not overly split).



Use clear, descriptive variable names.



Comment your code for key logic.



Use simple error handling with HTTP codes and JSON messages.



Inline logging calls with context-specific messages.



Use parameterized SQL queries to prevent injection (avoid string interpolation).



Separate concerns with folders like routes/, middlewares/, utils/, db/ in backend.



In frontend, use React functional components and hooks, keep UI minimal and accessible.



Follow a consistent app structure with a root entry file (server.js for backend, index.js/App.jsx for frontend).



Additional Notes

Your logging middleware should handle token authentication with the provided Test Server endpoints before sending logs.



Keep the logger usage DRY and reusable in both backend and frontend.



Default validity is 30 minutes if omitted.



Shortcodes must be globally unique; if a custom one is taken, respond with appropriate error.



Expired links should respond with HTTP 410 Gone.



All API responses, success or errors, should be in JSON format with meaningful messages.



Include all necessary validations on request bodies and query parameters.



You may use SQLite only (no other DBs), and no extra algorithmic libraries for core logic.



Your React app should provide a simple UX for bulk URL shortening and stats overview.



1. Official Test Server APIs (for Logging and Auth ONLY)

These are provided by AffordMed and are only used for logging events (not for business logic).



You will use them in your custom logger package, both in backend and frontend.



Endpoints:



POST /evaluation-service/register

Use this ONCE to register and get your clientID and clientSecret.



POST /evaluation-service/auth

Use this to get a Bearer token for logging. Required before sending any logs.



POST /evaluation-service/logs

Used by your logger util to send logs (events/errors/info) from both backend and frontend.



Base URL:

http://20.244.56.144



So, e.g.:



Register: http://20.244.56.144/evaluation-service/register



Authenticate: http://20.244.56.144/evaluation-service/auth



Logs: http://20.244.56.144/evaluation-service/logs



2. Your Own Backend APIs (URL Shortener Microservice)

These are the APIs your frontend will use to perform the main business logic — shortening, redirection, and analytics.



Endpoints:



POST /shorturls



Body: { url, validity, shortcode }



Response: { shortLink, expiry }



Use: To shorten a new URL.



GET /shorturls/:shortcode



Returns analytics/statistics about a specific short URL: original URL, click count, click details, creation/expiry.



GET /:shortcode



Handles actual redirection to the original URL (if not expired), tracks the click.



Your frontend may not call this directly—but browsers will when visiting the short link.



Base URL (typically):

http://localhost:8000



So, e.g.:



Shorten: http://localhost:8000/shorturls



Stats: http://localhost:8000/shorturls/abcd1



Redirect: http://localhost:8000/abcd1



Quick Reference Table

What do you want? Which API/URL Who uses it?

Register for credentials /evaluation-service/register You (once, manual)

Get log auth token /evaluation-service/auth Logger middleware

Send a log event /evaluation-service/logs Logger, all events

Shorten a URL /shorturls (POST) Your frontend app

Stats for a short URL /shorturls/:shortcode (GET) Your frontend app

Actual redirect of a short /:shortcode (GET) Browser/any client

How does your frontend fetch data?

To create a short URL:

fetch('http://localhost:8000/shorturls', { method: 'POST', body: ... })



To get analytics:

fetch('http://localhost:8000/shorturls/yourcode')



You NEVER fetch directly from the test server for your main app logic—only for logging.



Summary:



Use AffordMed test server /auth and /logs APIs ONLY for logging and event reporting (via your logger).



The rest of your app—frontend and backend—communicates with your own Express backend running on localhost:8000.



If you need concrete fetch examples or request/response body samples, let me know! this is my way of writing code "const express = require('express')

const {open} = require('sqlite')

const sqlite3 = require('sqlite3')

const bcrypt = require('bcrypt')

const jwt = require('jsonwebtoken')

const path = require('path')

const app = express()

const dbPath = path.join(__dirname, 'twitterClone.db')

app.use(express.json())



// initialize and Connecting Database...

let db = null

const initializeAndConnectDB = async () => {

  try {

    db = await open({

      filename: dbPath,

      driver: sqlite3.Database,

    })

    app.listen(3000, () =>

      console.log('Server Running at http://localhost:3000/'),

    )

  } catch (err) {

    console.log(`DB ERROR: ${err.message}`)

    process.exit(1)

  }

}

initializeAndConnectDB()



//section 1 (API 1) resgister user...



app.post('/register/', async (request, response) => {

  const {username, password, name, gender} = request.body



  const hashedPassword = await bcrypt.hash(password, 10)



  const getUserQuery = `

  SELECT 

  * 

  FROM 

  user 

  WHERE username = "${username}";`



  const dbUser = await db.get(getUserQuery)



  if (dbUser !== undefined) {

    response.status(400)

    response.send('User already exists')

  } else {

    if (password.length < 6) {

      response.status(400)

      response.send('Password is too short')

    } else {

      const createUserQuery = `

        INSERT INTO 

        user(username,password,name,gender)

        values (

          "${username}",

          "${hashedPassword}",

          "${name}",

          "${gender}"

        );`



      await db.run(createUserQuery)

      response.send('User created successfully')

    }

  }

})



//section 2 (API 2) Login user API...



app.post('/login/', async (request, response) => {

  const {username, password} = request.body

  const payload = {username}



  const getUserQuery = `

  SELECT 

  * 

  FROM 

  user 

  WHERE username = "${username}";`



  const dbUser = await db.get(getUserQuery)



  if (dbUser === undefined) {

    response.status(400)

    response.send('Invalid user')

  } else {

    const isPasswordMatched = await bcrypt.compare(password, dbUser.password)

    if (isPasswordMatched) {

      const jwtToken = jwt.sign(payload, 'itsPrasanthPassword')

      response.send({jwtToken})

    } else {

      response.status(400)

      response.send('Invalid password')

    }

  }

})



//section authtoken ### Authentication with JWT Token...



const authenticateToken = (request, response, next) => {

  const authToken = request.headers['authorization']

  let jwtToken

  if (authToken !== undefined) {

    jwtToken = authToken.split(' ')[1]

  }

  if (jwtToken === undefined) {

    response.status(401)

    response.send('Invalid JWT Token')

  } else {

    jwt.verify(jwtToken, 'itsPrasanthPassword', async (error, payload) => {

      if (error) {

        response.status(401)

        response.send('Invalid JWT Token')

      } else {

        const getUserId = `

        SELECT user_id as userId

        FROM user

        WHERE username = "${payload.username}";`



        const dbUser = await db.get(getUserId)

        request.userId = dbUser.userId

        next()

      }

    })

  }

}



// section 3 (API 3) Returns the latest tweets of people whom the user follows. Return 4 tweets at a time.



app.get('/user/tweets/feed/', authenticateToken, async (request, response) => {

  const userId = request.userId



  const getLatestTweetsQuery = `

  SELECT 

  username,tweet,date_time as dateTime

  FROM (user

  INNER JOIN follower

  ON user.user_id = follower.following_user_id) as temp

  INNER JOIN tweet 

  ON temp.user_id = tweet.user_id

  WHERE temp.follower_user_id = ${userId}

  ORDER BY date_time DESC

  LIMIT 4;`



  const latestTweets = await db.all(getLatestTweetsQuery)

  response.send(latestTweets)

})



//section 4 (API 4) Returns the list of all names of people whom the user follows



app.get('/user/following/', authenticateToken, async (request, response) => {

  const userId = request.userId



  const getFollowingUserNamesQuery = `

  SELECT name

  FROM (user 

  INNER JOIN follower

  ON user.user_id = follower.following_user_id) as temp

  WHERE temp.follower_user_id = ${userId};`



  const nameList = await db.all(getFollowingUserNamesQuery)

  response.send(nameList)

})



//section 5 (API 5) Returns the list of all names of people who follows the user



app.get('/user/followers/', authenticateToken, async (request, response) => {

  const userId = request.userId



  const getFollowerUserNamesQuery = `

  SELECT name

  FROM (user 

  INNER JOIN follower

  ON user.user_id = follower.follower_user_id) as temp

  WHERE temp.following_user_id = ${userId};`



  const nameList = await db.all(getFollowerUserNamesQuery)

  response.send(nameList)

})



// provide acess only if following...(middleware function)



const isPeopleInFollowingList = async (request, response, next) => {

  const {tweetId} = request.params

  const userId = request.userId



  const getFollowingUserId = `

  SELECT user_id as userId

  FROM tweet

  WHERE tweet_id = "${tweetId}";`



  const dbTweetUser = await db.get(getFollowingUserId)



  const getFollowingUserNameQuery = `

  SELECT name

  FROM (user 

  INNER JOIN follower

  ON user.user_id = follower.following_user_id) as temp

  WHERE temp.follower_user_id = ${userId} 

  AND 

  temp.following_user_id = ${dbTweetUser.userId};`



  const name = await db.get(getFollowingUserNameQuery)



  if (name === undefined) {

    response.status(401)

    response.send('Invalid Request')

  } else {

    next()

  }

}



//section 6 (API 6)



app.get(

  '/tweets/:tweetId/',

  authenticateToken,

  isPeopleInFollowingList,

  async (request, response) => {

    const {tweetId} = request.params

    const getTweetQuery = `

    SELECT tweet,

     COUNT(DISTINCT like_id) as likes,

     COUNT(DISTINCT reply) as replies,

     date_time as dateTime

     FROM tweet LEFT JOIN

     like ON tweet.tweet_id = like.tweet_id

     LEFT JOIN reply ON tweet.tweet_id = reply.tweet_id

     WHERE tweet.tweet_id = ${tweetId}

     GROUP BY tweet.tweet_id;`



    const tweet = await db.get(getTweetQuery)

    response.send(tweet)

  },

)



//section 7 (API 7)



app.get(

  '/tweets/:tweetId/likes/',

  authenticateToken,

  isPeopleInFollowingList,

  async (request, response) => {

    const {tweetId} = request.params



    const getLikedPeopleQuery = `

      SELECT username

      FROM (user INNER JOIN like

      ON user.user_id = like.user_id) as temp

      WHERE temp.tweet_id = ${tweetId};`



    const likedPeople = await db.all(getLikedPeopleQuery)

    const likes = likedPeople.map(item => item['username'])

    response.send({likes})

  },

)



// section 8 (API 8)



app.get(

  '/tweets/:tweetId/replies/',

  authenticateToken,

  isPeopleInFollowingList,

  async (request, response) => {

    const {tweetId} = request.params



    const getRepliesOfPeopleQuery = `

      SELECT name, reply 

      FROM (user INNER JOIN reply

      ON user.user_id = reply.user_id) as temp

      WHERE temp.tweet_id = ${tweetId};`



    const repliesOfPeople = await db.all(getRepliesOfPeopleQuery)

    const replies = repliesOfPeople.map(item => item)

    response.send({replies})

  },

)



//section 9 (API 9) Returns a list of all tweets of the user



app.get('/user/tweets/', authenticateToken, async (request, response) => {

  const userId = request.userId



  const getTweetQuery = `

     SELECT tweet,

     COUNT(DISTINCT like_id) as likes,

     COUNT(DISTINCT reply) as replies,

     date_time as dateTime

     FROM tweet LEFT JOIN

     like ON tweet.tweet_id = like.tweet_id

     LEFT JOIN reply ON tweet.tweet_id = reply.tweet_id

     WHERE tweet.user_id = ${userId}

     GROUP BY tweet.tweet_id;`



  const tweet = await db.all(getTweetQuery)

  response.send(tweet)

})



// section 10 (API 10) Create a tweet in the tweet table



app.post('/user/tweets/', authenticateToken, async (request, response) => {

  const userId = request.userId

  const {tweet} = request.body



  const addTweetQuery = `

  INSERT INTO

  tweet (tweet,user_id)

  values("${tweet}",${userId});`



  await db.run(addTweetQuery)

  response.send('Created a Tweet')

})



// section 11 (API 11)



app.delete(

  '/tweets/:tweetId/',

  authenticateToken,

  async (request, response) => {

    const userId = request.userId

    const {tweetId} = request.params



    const getTweetUserId = `

    SELECT user_id as userId

    FROM tweet

    WHERE tweet_id = ${tweetId};`



    const tweetUserId = await db.get(getTweetUserId)



    if (userId !== tweetUserId.userId) {

      response.status(401)

      response.send('Invalid Request')

    } else {

      const deleteTweetQuery = `

      DELETE FROM

      tweet 

      WHERE tweet_id = ${tweetId};`



      await db.run(deleteTweetQuery)

      response.send('Tweet Removed')

    }

  },

)



module.exports = app" for backend and for frontend use ths "https://github.com/prasanthxhx/Nxt-Watch"



Rocket



I understand you want to build a full-stack URL shortener microservice with analytical capabilities and custom logging middleware. This is a comprehensive web application that will use React for the frontend and Node.js/Express for the backend.



Let's start building your React web application for the URL shortener microservice! This will be a full-stack solution with:



Frontend: React with Material UI for bulk URL shortening and analytics

Backend: Express + SQLite microservice with URL shortening APIs

Logging: Custom middleware integrating with the test server

Features: Bulk URL processing (up to 5 URLs), analytics dashboard, click tracking

The system will handle URL shortening, expiry management, click analytics, and comprehensive logging across both frontend and backend components.



Rocket



Select the screens you wish to build from the list below. Token consumption is directly related to the number of screens generated.





URL Shortener Dashboard





Analytics Dashboard





Detailed Click Analytics



3 screen(s) selected



Rocket



I'm generating screens for your app.



URL Shortener Dashboard



Completed



Analytics Dashboard



Completed



Detailed Click Analytics



Completed



Rocket



Created URL Shortener Dashboard with bulk creation form, real-time validation, and custom shortcode assignment

Implemented analytics dashboard featuring KPI cards, interactive filtering, and comprehensive data tables

Built responsive two-panel layout with live preview, geographic data, and mobile-optimized views

Files (16)





Code diff







Rollback





Deliverables & Evaluation Considerations

Time Limit: 3 Hours (No extra time for pushing to GitHub)

• Code Implementation: Deliver a fully functional microservice and a

responsive React frontend web application that adhere to all specified API

and frontend requirements and general constraints, demonstrating robust

error handling, high code quality, and efficient API/Ul design suitable for a

production environment.Develop a HTTP URL Shortener Microservice

Ensure you've followed the instructions and registered provided in the Campus

Hiring Evaluation - Pre-Test Setup document before starting.

Your task is to develop a robust HTTP URL Shortener Microservice that provides

core URL shortening functionality along with basic analytical capabilities for the

shortened links.

Requirements & Constraints

• Mandatory Logging Integration: Your app MUST extensively use the Logging

Middleware you created in the Pre-Test Setup stage. Use of inbuilt language

loggers or console logging is not allowed.

• Microservice Architecture: Implement a single microservice capable of

handling the specified API endpoints.

• Authentication: For the purpose of this evaluation, assume users accessing

your APls are pre-authorized. Your application must not require user

registration or login mechanisms for API access.

• Short Link Uniqueness: All generated short links must be globally unique.

• Default Validity: If a user does not specify a validity period for a shortened URL,

it must default to 30 minutes. Validity input from the user will always be

provided as an integer representing minutes.

• Custom Shortcodes: Users may optionally provide a custom shortcode of their

choice. If a shortcode is provided, your service must attempt to use it, ensuring

it is unique and valid (e.g., alphanumeric, reasonable length). If no shortcode is

provided, your service must automatically generate a unique shortcode.

• Redirection: When

a

user

accesses

a shortened

URL (e.g.,

http://hostname:port/abcd1), the service must redirect them to the original long

URL.

• Error Handling: Implement robust error handling. Your API endpoints should

return appropriate HTTP status codes and descriptive JSON response bodies for

invalid requests (e.g., malformed input, non-existent shortcode, shortcode

collision, expired link).API Endpoints Specification

Your microservice must expose the following RESTful API endpoints:

Create Short URL

• Description: Creates a new shortened URL.

• Method: POST

• Route:

http://hostname: port/shorturls

• Request Body:

"url":

"https://very-very-very-long-and-descriptive-subdomain-that-goes-on-

and-on.somedomain.com/additional/directory/levels/for/more/length/re

ally-log-sub-domain/a-really-log-page",

"validity": 30,

"shortcode": "abcd1"

}

• url (string, required): The original long URL to be shortened. Must be a

valid URL format.

• validity (integer, optional): The duration in minutes for which the short

link remains valid. Defaults to 30 minutes if omitted.

• shortcode (string, optional): A desired custom shortcode. If omitted or

unavailable, a unique shortcode must be generated.

• Expected Response (Status Code: 201):

"shortLink": "https://hostname:port/abcd1",

"expiry": "2025-01-0100: 30:00Z"• shortLink: The complete shortened URL.

• expiry: The ISO 8601 formatted timestamp indicating when the short link

expires.

Retrieve Short URL Statistics

• Description: Retrieves usage statistics for a specific shortened URL.

• Method: GET

• Route:

http://hostname:port/shorturls/:abcd1

• The response must be a JSON object containing statistics related to the

specified shortcode, including:

• The total number of times the short link has been clicked.

• Information about the original URL it points to, its creation date, and its

expiry date.

• Detailed click data for each interaction, which should include the

timestamp of the click, the source from which the click originated (e.g.,

referrer), and a coarse-grained geographical location of the click.

Develop a React URL Shortener Web App

Develop a responsive React frontend web application that integrates with the

backend microservice to provide a user interface for URL shortening and analytics.

• Mandatory Logging Integration: Your app MUST extensively use the Logging

Middleware you created in the Pre-Test Setup stage. Use of inbuilt language

loggers or console logging is not allowed.

• Running Environment: Your React application must run exclusively on

http://localhost:3000.

• Integration: Your React application must be integrated with the backend APls

developed as part of this evaluation. The React application must not implement

the URL shortening logic or the statistics aggregation itself; it should solely

consume the backend APis for these functionalities.• User Experience: Care must be taken to avoid cluttering the page. The Ul must

prioritize user experience, with a focus on highlighting key elements of each

page.

• Styling Framework: Use Material Ul only. If you are not familiar with Material

Ul, employ native CSS. Use of ShadCN or other CSS Libraries is prohibited. Solely

relying on native CSS or not using Material Ul will result in lower scores.

Your application should consist of the following pages

URL Shortener Page

• Functionality: This page should allow users to shorten up to 5 URLS

concurrently. For each URL, the user should be able to provide:

• The original long URL

• An optional validity period (in minutes).

• An optional preferred shortcode.

• Client-Side Validation: Prior to making API calls to the backend, the user's

inputs should be validated client-side based on the constraints already

specified in the "General Requirements & Constraints" section (e.g., valid URL

format, validity as an integer).

• Display Results: Upon successful creation of shortened URLs, the

application must display the shortened links along with their respective

expiry dates, clearly associated with each original URL provided by the user.

URL Shortener Statistics Page

Functionality: This page should display a list of all shortened URLs created (either

in the current session or historically if data persistence is implemented and

accessible). For each listed shortened URL, it should clearly present:

• The shortened URL itself and its creation and expiry date times

• The total number of times the short link has been clicked.

• Detailed click data, including:

• The timestamp of each click.

• The source from which the click originatedSubmission Guidelines

• Create a Public Repository on your Github Account with your Roll Number as

the Repository Name

• For Backend/Frontend tracks, create 2 distinct folders inside the repository for

the following:

• Logging Middleware

• Backend/Frontend Test Submission

• For Full Stack tracks, create 3 distinct folders inside the repository for the

following:

• Logging Middleware

Afford Medical Technologies Private Limited

B 230 2nd Main Road, Sainikpuri, Hyderabad-500094, Telangana, INDIA. Phone: 91-40-27117068/27116133,

Web: www.affordmed.com, E-mail: contact@affordmed.com, CIN: U72200TG2007PTC056067, URN: UDYAM-TS-20-0013532

AFFORDMED®

Technology, Innovation & Affordabdity

• Backend Test Submission

• Frontend Test Submission

• Ensure that your Name, or any mention of Affordmed, is entirely absent from

the Repository Name, the README file, and all commit messages.

• For each question, submit comprehensive solutions. This includes your

architecture design, complete code and clear output screenshots. Incomplete

submissions will not be considered for evaluation.

• We strongly encourage you to commit and push your code to GitHub regularly,

at logical milestones in your development process. If you are using JavaScript or

TypeScript, don't forget to add node modules to your gitignore file.

• Please adhere to production-grade coding standards. This includes employing

proper naming conventions, maintaining a well-organised folder structure, and

providing appropriate comments within your code to enhance readability. This

is only an indicative list and you are encouraged to demonstrate other best

practices that you are aware of.

• For Backend Track or the Backend question of Full Stack Track, select any

Backend Framework without utilising external libraries for algorithms. Capture• Please adhere to production-grade coding standards. This includes employing

proper naming conventions, maintaining a well-organised folder structure, and

providing appropriate comments within your code to enhance readability. This

is only an indicative list and you are encouraged to demonstrate other best

practices that you are aware of.

• For Backend Track or the Backend question of Full Stack Track, select any

Backend Framework without utilising external libraries for algorithms. Capture

output screenshots from API clients like Insomnia or Postman, displaying

request body, response and response time for the average calculator

problem. The output screenshots have to be taken of API calls to your app and

not the test server

• For Frontend Track or the Frontend question of Full Stack Track, it is mandatory

to use React or Next. While JavaScript is permitted, the use of TypeScript is

preferred. Capture output screenshots of both mobile and desktop views of

your web application. For styling, only Material Ul or Vanilla CSS are permitted.

• Any instance of plagiarism, including using another applicant's API credentials,

LLMs will lead to immediate rejection.

Registration

You need to register with our Test Server to obtain your unique Client ID and

Client Secret.

Afford Medical Technologies Private Limited

B 230 2nd Main Road, Sainikpuri, Hyderabad-500094, Telangana, INDIA. Phone: 91-40-27117068/27116133,|

Web: www.affordmed.com, E-mail: contact@affordmed.com, CIN: U72200TG2007PTC056067, URN: UDYAM-TS-20-0013532|

AFFORDMED®

Technology, Innovation & Affordability

Requirements:

• Your Roll Number and Email, must align with your university/college email and

roll number. (Email must support Google Form verified submission)

• The GitHub Repository link you submit in the Google Form will be matched

against the GitHub Username provided during registration. Any mismatch will

result in your submission being ignored. If your GitHub Profile link is

https://github.com/username, submit only username while Registering.Requirements:

• Your Roll Number and Email, must align with your university/college email and

roll number. (Email must support Google Form verified submission)

• The GitHub Repository link you submit in the Google Form will be matched

against the GitHub Username provided during registration. Any mismatch will

result in your submission being ignored. If your GitHub Profile link is

https://github.com/username, submit only username while Registering.

• The accessCode required for registration has been shared via the email you

received. Do not use the example accessCode provided below.

Registration API (POST)

http://20.244.56.144/evaluation-service/register

Request Body

"email": "ramkrishna@abc. edu",

"name": "Ram Krishna",

"mobileNo": "9999999999",

"githubUsername": "github",

"rollNo":

"aalbb" ,

"accessCode": "xgAsNC"|

Response

You can register only once. Do not forget to save your clientiD and clientSecret; you cannot

retrieve them again.

"email": "ramkrishna@abc.edu",

"name": "ram krishna",

"rollNo":

"aalbb",AFFORDMED®

Technology, Innovation & Affordability

"accessCode": "xgAsNC" ,

"clientID": "d9cbb699-6a27-44a5-8d59-8b1befa816da",

"clientSecret": "tVJaaaRBSeXcRXe™"

Authentication

After successful registration, you must obtain an Authorization Token to access the Test Server APls.

Authorization Token API (POST)

http://20.244.56.144/evaluation-service/auth

Request Body

"email": "ramkrishna@abc. edu",

"name": "ram krishna",

"rollNo": "aalbb",

"accessCode": "xgAsNC",

"clientID": "d9cbb699-6a27-44a5-8d59-8b1befa816da",

"clientSecret": "tVJaaaRBSeXcRXeM"|

Response: (Status Code: 200)

"token_type": "Bearer",

"access_token":

"eyJhbGci0iJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJNYXBDbGFpbXMi0nsiZXhwIjoxNzQzNTc®MzQ®L

CJpYXQiOjE3NDM1NzQwNDQsImlzcyI6IkFmZm9yZG11ZCIsImp0aSI6ImQ5Y2JiNjk5LTZhMjctNDRh

NS04ZDU5LThiMWJ1ZmE4MTZkYSIsInN1YiI6InJhbWtyaXNobmFAYWJjLmVkdSJ9LCJlbWFpbCI6InJ

hbWtyaXNobmFAYWJjLmVkdSIsIm5hbWUi0iJyYW0ga3Jpc2huYSIsInJvbGx0byI6ImFhMWJiIiwiYw

NjZXNzQ29kZSI6InhnQXNOQyIsImNsawVudElEIjoiZD1jYmI20TktNmEyNy00NGE1LThkNTkt0GIxY

mVmYTgxNmRhIiwiY2xpZWS0U2VjcmV@IjoidFZKYWFhUkJTZVhjU1h]TSJ9.YApD98gq®IN_Oww7JMf

muUfK1m4hLTm7AIcLDcLAzVg",

"expires_in": 1743574344Develop Logging Middleware

The 'Logging Middleware' is a critical component for building robust and observable

applications. While error logging is essential, we expect you to implement logging that captures

the entire lifecycle of significant events within your application - from successful operations to

warnings, informational messages, and debugging details. Think of logs as the narrative of your

application's execution! These logs are crucial for understanding application behavior,

performance, and for effective debugging.

Note: While you have flexibility in choosing your backend language/framework, the Logging

Middleware must be a reusable package. If attempting the Full Stack track, both this middleware

and your backend application must be developed in TypeScript/JavaScript to enable the

logging package's consumption by the Frontend.

Write a reusable function that makes an API call to the Test Server each time the function is

called that matches the below structure:

Log (stack, level, package, message)

Integrate this reusable Log function strategically throughout your codebase. Each Log call

should provide specific and descriptive context about what's happening. Instead of generic

messages, aim for logs that clearly communicate the state, actions, and any relevant data at that

point in the code.

We encourage you to think critically about what information would be most valuable if you were

to troubleshoot your application months from now. That's the information you should be

logging.

// If an error occurs in your application's handler due to a data type mismatch

Log ("backend", "error", "handler", "received string, expected bool")

// If an error occurs in your application's db layer

Log ("backend", "fatal", "db", "Critical database connection failure.")

The test server has the below API that you can call in your Logging MiddlewareLog API (POST)

http://20.244.56.144/evaluation-service/logs

Constraints

• APlis a protected Route

Stack, Level and Package Fields accept only the following values (in lower case only)

Stack

"backend"

"frontend"

Level

"debug"

"info"

"warn"

"error"

"fatal"

Package

Packages that can only be used in Backend Application

"cache"

"controller"

"cron_job"

"db"

"domain"

"handler"

"repository"

"route"

"service"

Packages that can be only be used in Frontend Application

"api""component"

"hook"

"page"

"state"

"style"

Packages that can be used in both Backend and Frontend Application

"auth"

"config"

"middleware"

"utils"

Request Body

"stack": "backend",

"level": "error",

"package": "handler",

"message": "received string, expected bool"

Response (Status Code: 200)

"logID":

"a4aad02e-19d0-4153-86d9-58bf55d7c402",

"message": "log created successfully"subtloset sulacles

• Create a Public Repository on your Github Account with your Roll Number as

the Repository Name

• For Backend/Frontend tracks, create 2 distinct folders inside the repository for

the following:

• Logging Middleware

• Backend/Frontend Test Submission

• For Full Stack tracks, create 3 distinct folders inside the repository for the

following:

• Logging Middleware

Afford Medical Technologies Private Limited

B 230 2nd Main Road, Sainikpuri, Hyderabad-500094, Telangana, INDIA. Phone: 91-40-27117068/27116133,|

Web: www.affordmed.com, E-mail: contact@affordmed.com, CIN: U72200TG2007PTC056067, URN: UDYAM-TS-20-0013532

AFFORDMED®

Technology, Innovation & Affordability

• Backend Test Submission

• Frontend Test Submission

• Ensure that your Name, or any mention of Affordmed, is entirely absent from

the Repository Name, the README file, and all commit messages.

• For each question, submit comprehensive solutions. This includes your

architecture design, complete code and clear output screenshots. Incomplete

submissions will not be considered for evaluation.

• We strongly encourage you to commit and push your code to GitHub regularly,

at logical milestones in your development process. If you are using JavaScript or

TypeScript, don't forget to add node modules to your gitignore file.

• Please adhere to production-grade coding standards. This includes employing

proper naming conventions, maintaining a well-organised folder structure, and

providing appropriate comments within your code to enhance readability. This

is only an indicative list and you are encouraged to demonstrate other best

practices that you are aware of.

• For Backend Track or the Backend question of Full Stack Track, select any

Backend Framework without utilising external libraries for algorithms. Capture

output screenshots from API clients like Insomnia or Postman, displaying

request body. response and response time for the average calculatorRequirements:

• Your Roll Number and Email, must align with your university/college email and

roll number. (Email must support Google Form verified submission)

• The GitHub Repository link you submit in the Google Form will be matched

against the GitHub Username provided during registration. Any mismatch will

result in your submission being ignored. If your GitHub Profile link is

https://github.com/username, submit only username while Registering

• The accessCode required for registration has been shared via the email you

received. Do not use the example accessCode provided below.

Registration API (POST)

http://20.244.56.144/evaluation-service/register

Request Body

"email": "ramkrishna@abc. edu",

"name": "Ram Krishna",

"mobileNo": "9999999999",

"githubUsername": "github",

"rollNo": "aalbb",

"accessCode": "xgAsNC"

Response

You can register only once. Do not forget to save your clientiD and clientSecret; you cannot

retrieve them again.

{

"email": "ramkrishna@abc.edu",

"name": "ram krishna",

"rollNo": "aalbb","accessCode" :

"xgAsNC",

"clientID": "d9cbb699-6a27-44a5-8d59-8b1befa816da" ,

"clientSecret": "tVJaaaRBSeXcRXe™"|

Authentication

After successful registration, you must obtain an Authorization Token to access the Test Server APls.

Authorization Token API (POST)

http://20.244.56.144/evaluation-service/auth

Request Body

{

"email": "ramkrishnagabc.edu",

"name": "ram krishna",

"rollNo": "aalbb",

"accessCode": "xgAsNC",

"clientID": "d9cbb699-6a27-44a5-8d59-8b1befa816da",

"clientSecret": "tVJaaaRBSeXcRXe™"|

Response: (Status Code: 200)

"token_type": "Bearer",

"access_token":

"eyJhbGci0iJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJNYXBDbGFpbXMi0nsiZXhwIjoxNzQzNTc0MzQ0L

CJpYXQiOjE3NDM1NzQwNDQsImlzcyI6IkFmZm9yZG11ZCIsImp®aSI6ImQ5Y2JiNjk5LTZhMjctNDRh|

NS04ZDU5LThiMWJlZmE4MTZkYSIsInN1YiI6InJhbWtyaXNobmFAYWJjLmVkdSJ9LCJlbWFpbCI6InJ

hbWtyaXNobmFAYWJjLmVkdSIsIm5hbWUiOiJyYW0ga3Jpc2huYSIsInJvbGx0by]6ImFhMWJiIiwiYW

NjZXNzQ29kZSI6InhnQXNOQyIsImNsaWVudE1EIjoiZD1jYm]20TktNmEyNy@®NGE1LThkNTkt0GIxY|

mVmYTgxNmRhIiwiY2xpZW50U2VjcmV0IjoidFZKYWFhUkJTzVhjUlhlTSJ9.YApD98gq®IN_Oww73Mf

muUfK1m4hLTm7AIcLDcLAzVg",

"expires_in": 1743574344The 'Logging Middleware' is a critical component for building robust and observable

applications. While error logging is essential, we expect you to implement logging that captures

the entire lifecycle of significant events within your application - from successful operations to

warnings, informational messages, and debugging details. Think of logs as the narrative of your

application's execution! These logs are crucial for understanding application behavior,

performance, and for effective debugging.

Note: While you have flexibility in choosing your backend language/framework, the Logging

Middleware must be a reusable package. If attempting the Full Stack track, both this middleware

and your backend application must be developed in TypeScript/JavaScript to enable the

logging package's consumption by the Frontend.

Write a reusable function that makes an API call to the Test Server each time the function is

called that matches the below structure:

Log(stack, level, package, message)

Integrate this reusable Log function strategically throughout your codebase. Each Log cal

should provide specific and descriptive context about what's happening. Instead of generic

messages, aim for logs that clearly communicate the state, actions, and any relevant data at that

point in the code.

We encourage you to think critically about what information would be most valuable if you were

to troubleshoot your application months from now. That's the information you should be

logging!

// If an error occurs in your application's handler due to a data type mismatch

Log(backend", "error", "handler", "received string, expected bool")

// If an error occurs in your application's db layer

Log("backend", "fatal", "db", "Critical database connection failure.")

The test server has the below API that you can call in your Logging MiddlewareLog API (POST)

http://20.244.56.144/evaluation-service/logs

Constraints

APl is a protected Route

• Stack, Level and Package Fields accept only the following values (in lower case only)

Stack

"backend"

"frontend"

Level

"debug"

"info"

"warn"

"error"

"fatal"

Package

Packages that can only be used in Backend Application

"cache"

"controller"

"cron_job"

"db"

"domain"

"handler"

"repository"

"route"

"service"

Packages that can be only be used in Frontend ApplicationTerralogy, Innovation & Affordabilty D

"component"

"hook"

"page"

"state"

"style"

Packages that can be used in both Backend and Frontend Application

"auth"

"config"

"middleware"

"utils"

Request Body

"stack": "backend",

"level": "error",

"package": "handler",

"message": "received string, expected bool"

Response (Status Code: 200)

"logID":

"a4aad02e-19d0-4153-86d9-58bf55d7c402",

"message": "log created successfully"

Myy access code is Code: PrjyQF

